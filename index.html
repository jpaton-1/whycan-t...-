<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Why can't this be a community garden? (Location Based v2)</title>

    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gwendolyn:wght@700&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* Styles remain the same as previous version */
        body { margin: 0; padding: 0; font-family: 'Roboto', Arial, sans-serif; overflow: hidden; background-color: #000; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 3000; text-align: center; padding: 20px; box-sizing: border-box; }
        #loading h1 { font-family: 'Roboto', sans-serif; font-weight: 700; font-size: 2.5em; margin-bottom: 15px; }
        #loading p { font-size: 1.1em; margin-bottom: 20px;}
        .arjs-loader-display { position: fixed; z-index: 9999; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; text-align: center; color: white; font-family: 'Roboto', sans-serif;}
        .arjs-loader-display p { font-size: 1.2em; padding: 0 20px;}
        .message-container-style { color: white; background: none; padding: 5px; text-align: center; font-family: 'Gwendolyn', cursive; font-weight: 700; font-size: 8vw; line-height: 1.1; pointer-events: none; text-shadow: 1px 1px 2px rgba(0,0,0,0.7), 2px 2px 5px rgba(0,0,0,0.5); white-space: normal; max-width: 90%; box-sizing: border-box; position: fixed; top: 10%; left: 50%; transform: translateX(-50%); z-index: 100; }
        .dynamic-response-display-style { color: #C8FFC5; background-color: rgba(0, 0, 0, 0.65); padding: 8px 12px; border-radius: 8px; text-align: center; font-family: 'Roboto', sans-serif; font-size: 15px; font-weight: 400; pointer-events: auto; max-width: 250px; box-sizing: border-box; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); position: fixed; bottom: 150px; left: 50%; transform: translateX(-50%); z-index: 100; display: none; }
        .controls { position: fixed; bottom: 20px; width: 100%; display: flex; justify-content: space-around; padding: 0 20px; box-sizing: border-box; z-index: 1000; }
        .btn { width: 60px; height: 60px; border-radius: 50%; color: white; border: none; font-family: 'Roboto', sans-serif; font-size: 28px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.4); cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; }
        #place-btn { background-color: #4CAF50; display: none;} 
        #reset-btn { background-color: #f44336; display: none; }
        #response-toggle { background-color: #2196F3; display: none; }
        #response-form-container { position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(5px); border-radius: 15px; padding: 20px; color: white; z-index: 1001; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        #response-form-container input, #response-form-container textarea { width: calc(100% - 20px); padding: 10px; margin: 8px 0 12px; border: 1px solid #555; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 16px; }
        #response-form-container textarea { height: 80px; resize: none; } 
        #response-form-container button { background: #4CAF50; color: white; border: none; padding: 12px 18px; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; font-size: 16px; }
        #response-form-container h3 { margin-top: 0; text-align: center; font-weight: 700; } 
        #response-status { margin-top: 12px; text-align: center; font-weight: bold; min-height: 20px; }
        #instructions { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.75); backdrop-filter: blur(3px); color: white; padding: 12px 18px; border-radius: 10px; text-align: center; font-size: 16px; z-index: 1000; max-width: 80%;}
        #permission-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 4000; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; padding: 20px; }
        #permission-overlay h2 { font-weight: 700; } 
        #permission-btn { margin-top: 20px; padding: 12px 24px; background-color: #4CAF50; color: white; border: none; border-radius: 30px; font-size: 18px; font-weight: 700; cursor: pointer; }
        #debug-info { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 8px 12px; border-radius: 5px; font-size: 11px; font-family: monospace; z-index: 2500; display: none; width: calc(100% - 40px); max-height: 150px; overflow-y: auto; }
        .location-info-style { position: fixed; bottom: 100px; left: 10px; color: white; background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 5px; font-family: 'Roboto', sans-serif; font-size: 12px; z-index: 999; }
    </style>

    <script id="flowerVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv; varying vec2 vInstanceRandomVec2; varying float vInstanceStemGrowTime; varying float vInstanceFlowerGrowTime;
        attribute vec2 instanceRandomVec2; attribute float instanceStemGrowTime; attribute float instanceFlowerGrowTime;
        void main() {
            vUv = uv; vInstanceRandomVec2 = instanceRandomVec2; vInstanceStemGrowTime = instanceStemGrowTime; vInstanceFlowerGrowTime = instanceFlowerGrowTime;
            gl_Position = projectionMatrix * viewMatrix * instanceMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="flowerFragmentShader" type="x-shader/x-fragment">
        #define PI 3.14159265359
        precision highp float;
        uniform float u_time; // Global time
        varying vec2 vUv;
        varying vec2 vInstanceRandomVec2;
        varying float vInstanceStemGrowTime;
        varying float vInstanceFlowerGrowTime;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
        float snoise(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i = floor(v + dot(v, C.yy)); vec2 x0 = v - i + dot(i, C.xx); vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0)); vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0); m = m*m; m = m*m; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h); vec3 g; g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }
        float easeQuinticInOut(float t) { return t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * (--t) * t * t * t * t; }
        float get_flower_shape(vec2 _p, float _pet_n, float _angle, float _outline, float flowerTime, vec2 randomVec, float globalTime) { _angle *= 3.0; float bloomCompletion = min(flowerTime / 2.0, 1.0); if (bloomCompletion >= 1.0) { _angle += sin(globalTime * 0.3 + randomVec.y * 5.0) * 0.1; } _p = vec2(_p.x * cos(_angle) - _p.y * sin(_angle), _p.x * sin(_angle) + _p.y * cos(_angle)); float a = atan(_p.y, _p.x); float flower_sectoral_shape = pow(abs(sin(a * _pet_n)), 0.4) + 0.25; vec2 flower_size_range = vec2(0.03, 0.1); float base_scale_factor = 0.55; float size = (flower_size_range[0] + randomVec[0] * flower_size_range[1]) * base_scale_factor; if (bloomCompletion >= 1.0) { size *= (1.0 + sin(globalTime * 0.7 + randomVec.x * 6.0) * 0.03); } float dist = length(_p); float flower_radial_shape = pow(dist / size, 2.0); float texture_noise = snoise((_p + randomVec) * 20.0) * 0.05; flower_radial_shape += texture_noise * bloomCompletion; flower_radial_shape -= 0.1 * sin(8.0 * a); flower_radial_shape = max(0.1, flower_radial_shape); float normalizedFlowerTime = min(flowerTime / 2.0, 1.0); float grow_progress = easeQuinticInOut(normalizedFlowerTime); float shape_value = smoothstep(flower_sectoral_shape, flower_sectoral_shape * 0.8, flower_radial_shape); float flower_shape = shape_value * grow_progress; return flower_shape; }
        float get_stem_shape(vec2 _p, vec2 _plane_uv, float _w, float _angle, float stemTime, vec2 randomVec) { _w = max(0.004, _w); _w *= 0.6; float bend_amount = 0.8; float x_offset = _p.y * sin(_angle * 2.0) * bend_amount; x_offset *= pow(max(0.0, _plane_uv.y), 1.5); _p.x -= x_offset; float noise_power = 0.6; float stem_noise = noise_power * snoise(8.0 * _plane_uv + randomVec[0] * 5.0); stem_noise *= smoothstep(0.0, 0.15, length(_p)); stem_noise *= smoothstep(0.0, 0.05, _plane_uv.y); _p.x += stem_noise * 0.1; float left = smoothstep(-_w, 0.0, _p.x); float right = 1.0 - smoothstep(0.0, _w, _p.x); float stem_line = left * right; float normalizedStemTime = min(stemTime / 1.0, 1.0); float grow_progress = easeQuinticInOut(normalizedStemTime); float grow_height = -0.5 + grow_progress * 0.5; float height_mask = smoothstep(grow_height - 0.05, grow_height, _p.y); float stem_shape = stem_line * height_mask; stem_shape *= smoothstep(0.01, -0.01, _p.y); stem_shape *= step(0.0, _plane_uv.y); return stem_shape; }
        void main() { vec2 centeredUv = vUv - 0.5; vec3 stem_color = vec3(0.1 + vInstanceRandomVec2[0] * 0.6, 0.6, 0.2); vec3 flower_color_base = vec3(0.6 + 0.5 * vInstanceRandomVec2[1], 0.1, 0.9 - 0.5 * vInstanceRandomVec2[1]); float angle = 1.5 * (vInstanceRandomVec2[0] - 0.5); float stem_shape = get_stem_shape(centeredUv, vUv, 0.007, angle, vInstanceStemGrowTime, vInstanceRandomVec2); float color_noise_val = (snoise(vUv * 15.0 + vInstanceRandomVec2 * 2.0) + 1.0) * 0.5; color_noise_val = pow(color_noise_val, 1.5); vec3 flower_color_textured = flower_color_base * (0.8 + color_noise_val * 0.4); float petals_back_number = 2.0 + floor(vInstanceRandomVec2[0] * 3.0); float angle_offset_current = -(2.0 * step(0.0, angle) - 1.0) * 0.2 * min(vInstanceFlowerGrowTime, 2.0); float flower_back_shape = get_flower_shape(centeredUv, petals_back_number, angle + angle_offset_current, 1.5, vInstanceFlowerGrowTime, vInstanceRandomVec2, u_time); float petals_front_number = 3.0 + floor(vInstanceRandomVec2[1] * 3.0); float flower_front_shape = get_flower_shape(centeredUv, petals_front_number, angle, 1.0, vInstanceFlowerGrowTime, vInstanceRandomVec2, u_time); vec3 final_color = vec3(0.0); final_color += (stem_shape * stem_color); final_color += (flower_back_shape * (flower_color_textured + vec3(0.0, 0.6 * min(vInstanceFlowerGrowTime / 2.0, 1.0), 0.0))); final_color += (flower_front_shape * flower_color_textured); final_color.r *= 1.0 - (0.5 * flower_back_shape * flower_front_shape); final_color.b *= 1.0 - (flower_back_shape * flower_front_shape); float alpha = max(stem_shape, max(flower_back_shape, flower_front_shape)); alpha = smoothstep(0.0, 0.02, alpha); alpha *= 0.75; if (alpha < 0.01) discard; gl_FragColor = vec4(final_color, alpha); }
    </script>
</head>

<body>
    <div id="loading">
        <h1>Why can't...?</h1>
        <p>Initializing garden experience...</p>
         <p style="font-size: 0.8em; margin-top: 20px;">(Ensure you allow Camera and Location access and are using HTTPS)</p>
    </div>

    <div class="arjs-loader-display">
        <p>Starting AR... Requesting permissions...</p>
    </div>

    <div id="permission-overlay">
         <h2>Permissions Required</h2>
         <p>This AR experience needs access to device motion sensors.</p>
         <button id="permission-btn">Allow Motion Sensors</button>
    </div>

    <div id="main-message-display" class="message-container-style" style="display: none;">
        <p>Why can't this be a community garden?</p>
    </div>
    <div id="dynamic-response-text-display" class="dynamic-response-display-style"></div>
    <div id="instructions">Point your camera around. The garden will appear if you are near the location.</div>
    <div class="controls">
        <button id="response-toggle" class="btn" title="Share Thoughts">+</button>
        <button id="reset-btn" class="btn" title="Hide Garden">↺</button>
    </div>
    <div id="response-form-container">
        <h3>Share Your Thoughts</h3>
        <form id="garden-response-form-actual">
            <label for="name">Your Name:</label>
            <input type="text" id="name" name="name" placeholder="e.g., Alex P." required>
            <label for="form-message">Why can't this be a community garden?</label>
            <textarea id="form-message" name="message" placeholder="Your ideas..." required></textarea>
            <button type="submit">Submit Idea</button>
        </form>
        <div id="response-status"></div>
    </div>
    <div id="debug-info"></div>

    <a-scene
        id="ar-scene"
        vr-mode-ui="enabled: false"
        embedded
        renderer="logarithmicDepthBuffer: true; colorManagement: true; physicallyCorrectLights: true;"
        arjs="
            sourceType: webcam;
            trackingMethod: best; 
            debugUIEnabled: false;
            detectionMode: mono_and_matrix;
            matrixCodeType: 3x3;
            sourceWidth: 1280; sourceHeight: 960;
            displayWidth: 1280; displayHeight: 960;"
        location-check="targetLat: 35.995666; targetLon: -78.910711; threshold: 50; debugElement: #debug-info"
        loading-screen-manager>

        <a-entity id="gps-garden"
            gps-projected-entity-place="latitude: 35.996417; longitude: -78.909944;" /* REPLACE WITH YOUR TARGET COORDS */
            visible="false"
            styled-flower-garden="flowerCount: 150; radius: 10;">
        </a-entity>

        <a-camera gps-new-camera="gpsMinDistance: 5; gpsTimeInterval: 1000" rotation-reader></a-camera>
    </a-scene>

    <script>
        // Helper functions for distance calculation (remain the same)
        function toRadians(degrees) { return degrees * Math.PI / 180; }
        function toDegrees(radians) { return radians * 180 / Math.PI; }
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = toRadians(lat1); const φ2 = toRadians(lat2);
            const Δφ = toRadians(lat2 - lat1); const Δλ = toRadians(lon2 - lon1);
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in meters
        }

        // Loading Screen Manager Component (remains the same)
        AFRAME.registerComponent('loading-screen-manager', {
            init: function () {
                const loadingScreen = document.getElementById('loading');
                const arjsLoaderDisplay = document.querySelector('.arjs-loader-display'); 
                
                if(arjsLoaderDisplay) arjsLoaderDisplay.style.display = 'none'; // Hide AR.js default initially

                this.el.sceneEl.addEventListener('arjs-video-loaded', () => {
                    console.log('AR.js video loaded');
                     // Sometimes good to hide loading here if GPS isn't needed immediately
                    if (loadingScreen && loadingScreen.style.display !== 'none') {
                       // loadingScreen.style.display = 'none'; // Uncomment if preferred
                       // console.log('Main loading screen hidden on video load.');
                    }
                });
                this.el.sceneEl.addEventListener('arjs-gps-camera-loading', () => {
                    console.log('AR.js GPS Camera loading');
                    if(loadingScreen) loadingScreen.style.display = 'flex'; // Ensure loading is visible
                });
                 // UPDATE: Listen to gps-camera-origin-coord-set for location init confirmation
                this.el.sceneEl.addEventListener('gps-camera-origin-coord-set', () => {
                    console.log('AR.js GPS Camera origin coordinates SET');
                    if (loadingScreen && loadingScreen.style.display !== 'none') {
                        loadingScreen.style.display = 'none';
                        console.log('Main loading screen hidden.');
                    }
                });
                 // Fallback - keep timeout
                setTimeout(() => {
                    if (loadingScreen && loadingScreen.style.display !== 'none') {
                        loadingScreen.style.display = 'none';
                        console.log('Main loading screen hidden by timeout.');
                    }
                }, 10000); // Extended timeout slightly
            }
        });


        // Styled Flower Garden Component (UPDATED TO USE AFRAME.THREE)
        AFRAME.registerComponent('styled-flower-garden', {
            schema: {
                flowerCount: { type: 'number', default: 100 },
                radius: { type: 'number', default: 15 },
                minHeight: {type: 'number', default: -1.0},
                maxHeight: {type: 'number', default: 0.5}
            },

            init: function () {
                // Use AFRAME.THREE namespace
                this.THREE = AFRAME.THREE;
                this.sceneEl = this.el.sceneEl;
                this.camera = this.sceneEl.camera;
                this.clock = new this.THREE.Clock();

                this.MAX_FLOWERS = this.data.flowerCount;
                this.currentFlowerCount = 0;
                this.instanceStemGrowTimes = new Float32Array(this.MAX_FLOWERS);
                this.instanceFlowerGrowTimes = new Float32Array(this.MAX_FLOWERS);
                this.instanceRandomVec2s = new Float32Array(this.MAX_FLOWERS * 2);
                this.instanceStemGrowDuration = new Float32Array(this.MAX_FLOWERS);
                this.instanceFlowerGrowDuration = new Float32Array(this.MAX_FLOWERS);
                this.instanceIsBlooming = new Array(this.MAX_FLOWERS).fill(false);
                this.dummy = new this.THREE.Object3D();

                this.initFlowers();

                // Add text using A-Frame entity
                const textEl = document.createElement('a-text');
                textEl.setAttribute('value', "Why can't this be a community garden?");
                textEl.setAttribute('align', 'center');
                textEl.setAttribute('color', '#FFF');
                textEl.setAttribute('width', '6');
                textEl.setAttribute('position', `0 ${this.data.maxHeight + 1.0} 0`);
                textEl.setAttribute('look-at', '[gps-new-camera]'); // UPDATE look-at target
                this.el.appendChild(textEl);

                 // Add the InstancedMesh once the entity's object3D is ready
                 this.el.addEventListener('object3dset', () => {
                     if (this.el.object3D && this.instancedFlowers) {
                         this.el.object3D.add(this.instancedFlowers);
                         console.log('Styled Flower Garden: InstancedMesh added to A-Frame entity.');
                         // Place flowers only when the component/entity becomes visible
                         if(this.el.getAttribute('visible')) {
                            this.placeFlowers();
                         }
                     }
                 });

                 // Handle visibility change to place/reset flowers
                 this.el.addEventListener('componentchanged', (evt) => {
                    if (evt.detail.name === 'visible') {
                        if (evt.detail.newData === true && this.instancedFlowers) {
                            console.log('Styled Flower Garden: Became visible, placing flowers.');
                            this.placeFlowers();
                        } else if (evt.detail.newData === false && this.instancedFlowers) {
                             console.log('Styled Flower Garden: Became hidden, resetting flowers.');
                            this.resetFlowers();
                        }
                    }
                });
            },

            initFlowers: function () {
                const baseFlowerGeometry = new this.THREE.PlaneGeometry(1.8, 1.8);
                const baseFlowerMaterial = new this.THREE.ShaderMaterial({
                    uniforms: { u_time: { value: 0.0 } },
                    vertexShader: document.getElementById('flowerVertexShader').textContent,
                    fragmentShader: document.getElementById('flowerFragmentShader').textContent,
                    transparent: true,
                    side: this.THREE.DoubleSide,
                    depthWrite: false
                });

                this.instancedFlowers = new this.THREE.InstancedMesh(baseFlowerGeometry, baseFlowerMaterial, this.MAX_FLOWERS);
                this.instancedFlowers.instanceMatrix.setUsage(this.THREE.DynamicDrawUsage); // Use THREE namespace
                this.instancedFlowers.geometry.setAttribute('instanceRandomVec2', new this.THREE.InstancedBufferAttribute(this.instanceRandomVec2s, 2));
                this.instancedFlowers.geometry.setAttribute('instanceStemGrowTime', new this.THREE.InstancedBufferAttribute(this.instanceStemGrowTimes, 1));
                this.instancedFlowers.geometry.setAttribute('instanceFlowerGrowTime', new this.THREE.InstancedBufferAttribute(this.instanceFlowerGrowTimes, 1));
                this.instancedFlowers.count = 0;
                 // Mesh added via 'object3dset' listener
            },

             placeFlowers: function () {
                 if (!this.instancedFlowers || !this.el.object3D) { // Check if object3D is ready
                     console.warn("placeFlowers: InstancedMesh or entity object3D not ready yet.");
                     // Attempt to add mesh again if not already added
                     if (this.el.object3D && this.instancedFlowers && !this.instancedFlowers.parent) {
                         this.el.object3D.add(this.instancedFlowers);
                     }
                     // Optionally retry placement after a short delay if initialization races occur
                     // setTimeout(() => { this.placeFlowers(); }, 100); 
                     return;
                 }
                if (this.currentFlowerCount > 0) {
                    console.log("placeFlowers: Flowers already seem placed or count > 0. Resetting first.");
                    this.resetFlowers(); // Ensure clean state before placing
                }

                const flowerCount = this.MAX_FLOWERS;
                const radius = this.data.radius;
                const minHeight = this.data.minHeight;
                const maxHeight = this.data.maxHeight;

                console.log(`placeFlowers: Attempting to place ${flowerCount} flowers.`);

                this.instanceIsBlooming.fill(false);
                this.instanceStemGrowTimes.fill(0);
                this.instanceFlowerGrowTimes.fill(0);
                this.instanceRandomVec2s.fill(0);
                this.instanceStemGrowDuration.fill(0);
                this.instanceFlowerGrowDuration.fill(0);

                for (let i = 0; i < flowerCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const y = minHeight + Math.random() * (maxHeight - minHeight);

                    this.dummy.position.set(x, y, z);
                    this.dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);
                    const scaleVariation = 0.6 + Math.random() * 0.8;
                    this.dummy.scale.set(scaleVariation, scaleVariation, scaleVariation);
                    this.dummy.updateMatrix();
                    this.instancedFlowers.setMatrixAt(i, this.dummy.matrix);

                    this.instanceRandomVec2s[i * 2 + 0] = Math.random();
                    this.instanceRandomVec2s[i * 2 + 1] = Math.random();
                    this.instanceStemGrowTimes[i] = 0.0;
                    this.instanceFlowerGrowTimes[i] = 0.0;
                    this.instanceStemGrowDuration[i] = 1.0;
                    this.instanceFlowerGrowDuration[i] = 2.0;
                    
                    setTimeout(() => { if(this.instanceIsBlooming) this.instanceIsBlooming[i] = true; }, 200 + Math.random() * 3000);
                }
                this.instancedFlowers.instanceMatrix.needsUpdate = true;
                if (this.instancedFlowers.geometry.attributes.instanceRandomVec2) this.instancedFlowers.geometry.attributes.instanceRandomVec2.needsUpdate = true;
                if (this.instancedFlowers.geometry.attributes.instanceStemGrowTime) this.instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                if (this.instancedFlowers.geometry.attributes.instanceFlowerGrowTime) this.instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;
                this.instancedFlowers.count = flowerCount; // Set count AFTER loop
                this.currentFlowerCount = flowerCount; // Update internal count
                console.log(`Styled Flower Garden: Placed ${this.currentFlowerCount} flowers.`);
            },
            
            resetFlowers: function() {
                if (this.instancedFlowers) {
                    this.instancedFlowers.count = 0;
                    if (this.instancedFlowers.instanceMatrix) this.instancedFlowers.instanceMatrix.needsUpdate = true;
                    this.instanceIsBlooming.fill(false); // Reset blooming state array
                    this.instanceStemGrowTimes.fill(0);
                    this.instanceFlowerGrowTimes.fill(0);
                    this.currentFlowerCount = 0;
                    console.log("Styled Flower Garden: Flowers reset.");
                }
            },

            tick: function (time, deltaTime) {
                if (!this.instancedFlowers || this.currentFlowerCount === 0 || !this.el.getAttribute('visible')) return; // Use currentFlowerCount

                const dt = deltaTime / 1000;
                const elapsedTime = this.clock.getElapsedTime();

                if (this.instancedFlowers.material.uniforms.u_time) {
                    this.instancedFlowers.material.uniforms.u_time.value = elapsedTime;
                }

                let needsStemTimeUpdate = false;
                let needsFlowerTimeUpdate = false;
                let needsMatrixUpdate = false; // Flag for billboarding changes

                for (let i = 0; i < this.currentFlowerCount; i++) { // Use currentFlowerCount
                    if (this.instanceIsBlooming && this.instanceIsBlooming[i]) { // Check if array exists
                        let currentStemTime = this.instanceStemGrowTimes[i];
                        let currentFlowerTime = this.instanceFlowerGrowTimes[i];
                        const stemDuration = this.instanceStemGrowDuration[i];
                        const flowerDuration = this.instanceFlowerGrowDuration[i];

                        if (currentStemTime < stemDuration) {
                            currentStemTime += dt;
                            if(this.instancedFlowers.geometry.attributes.instanceStemGrowTime) this.instancedFlowers.geometry.attributes.instanceStemGrowTime.setX(i, currentStemTime);
                            needsStemTimeUpdate = true;
                        } else if (currentFlowerTime < flowerDuration) {
                            currentFlowerTime += dt;
                             if(this.instancedFlowers.geometry.attributes.instanceFlowerGrowTime) this.instancedFlowers.geometry.attributes.instanceFlowerGrowTime.setX(i, currentFlowerTime);
                            needsFlowerTimeUpdate = true;
                        }
                        this.instanceStemGrowTimes[i] = currentStemTime;
                        this.instanceFlowerGrowTimes[i] = currentFlowerTime;
                    }
                }

                if (needsStemTimeUpdate && this.instancedFlowers.geometry.attributes.instanceStemGrowTime) this.instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                if (needsFlowerTimeUpdate && this.instancedFlowers.geometry.attributes.instanceFlowerGrowTime) this.instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;
                
                // Billboarding logic
                 if (this.camera && this.camera.el && this.camera.el.object3D && this.el.object3D) {
                    const camWorldPos = new this.THREE.Vector3();
                    this.camera.el.object3D.getWorldPosition(camWorldPos); // Get camera world position

                     const parentWorldMatrix = this.el.object3D.matrixWorld;
                     const parentInverseWorldMatrix = new this.THREE.Matrix4().copy(parentWorldMatrix).invert();

                    for (let i = 0; i < this.currentFlowerCount; i++) { // Use currentFlowerCount
                        this.instancedFlowers.getMatrixAt(i, this.dummy.matrix); // Get current local matrix

                        // Decompose local matrix to get local position
                        const localPos = new this.THREE.Vector3();
                        const localQuat = new this.THREE.Quaternion(); // Store original quaternion if needed
                        const localScale = new this.THREE.Vector3();
                        this.dummy.matrix.decompose(localPos, localQuat, localScale);

                        // Calculate world position of the instance
                        const instanceWorldPos = localPos.clone().applyMatrix4(parentWorldMatrix);

                        // Calculate lookAt matrix in world space
                        this.dummy.position.copy(instanceWorldPos);
                        this.dummy.scale.copy(localScale); // Keep original scale
                        this.dummy.lookAt(camWorldPos);
                        this.dummy.updateMatrixWorld(true); // Force update world matrix after lookAt

                        // Convert the world matrix back to local space relative to the parent entity
                        this.dummy.matrix.premultiply(parentInverseWorldMatrix);

                        // Set the updated local matrix
                        this.instancedFlowers.setMatrixAt(i, this.dummy.matrix);
                        needsMatrixUpdate = true;
                    }
                    if (needsMatrixUpdate) {
                        this.instancedFlowers.instanceMatrix.needsUpdate = true;
                    }
                 }
            }
        });

        // Location Proximity Checker (UPDATED TO LISTEN for gps-new-camera)
        AFRAME.registerComponent('location-check', {
            schema: {
                targetLat: { type: 'number', default: 0 },
                targetLon: { type: 'number', default: 0 },
                threshold: { type: 'number', default: 50 },
                debugElement: {type: 'selector'}
            },
            init: function () {
                this.gardenEntity = document.getElementById('gps-garden');
                this.mainMessageDisplay = document.getElementById('main-message-display');
                this.dynamicResponseDisplay = document.getElementById('dynamic-response-text-display');
                this.responseToggleBtn = document.getElementById('response-toggle');
                this.resetBtn = document.getElementById('reset-btn');
                this.instructionsDiv = document.getElementById('instructions');
                this.hasEnteredRange = false; // Track if user has entered the range

                if (!this.gardenEntity) {
                    console.error("Location Check: gps-garden entity not found!"); return;
                }
                this.debugEl = this.data.debugElement;
                if (this.debugEl) this.debugEl.style.display = 'block';

                console.log(`Location Check Initialized: Target ${this.data.targetLat}, ${this.data.targetLon}, Threshold: ${this.data.threshold}m`);

                 // UPDATE: Listen to gps-new-camera update event
                 window.addEventListener('gps-camera-update-position', (event) => {
                    if (!event.detail || !event.detail.position) {
                        console.warn('Location Check: gps-camera-update-position event missing details.');
                        return;
                    }
                    const currentLat = event.detail.position.latitude;
                    const currentLon = event.detail.position.longitude;
                    const distance = calculateDistance(currentLat, currentLon, this.data.targetLat, this.data.targetLon);

                    if (this.debugEl) {
                        this.debugEl.innerHTML = `Current: ${currentLat.toFixed(6)}, ${currentLon.toFixed(6)}<br>Target: ${this.data.targetLat.toFixed(6)}, ${this.data.targetLon.toFixed(6)}<br>Distance: ${distance.toFixed(1)}m`;
                    }

                    if (distance < this.data.threshold) {
                        if (!this.hasEnteredRange) { // Only trigger on first entry
                             this.hasEnteredRange = true;
                             this.gardenEntity.setAttribute('visible', true); // Visibility change triggers flower placement via listener
                             if(this.mainMessageDisplay) this.mainMessageDisplay.style.display = 'block';
                             if(this.dynamicResponseDisplay) this.dynamicResponseDisplay.style.display = 'block';
                             if(this.responseToggleBtn) this.responseToggleBtn.style.display = 'flex';
                             if(this.resetBtn) this.resetBtn.style.display = 'flex';
                             if(this.instructionsDiv) this.instructionsDiv.style.display = 'none';
                             loadAndCycleResponses(true);
                             console.log("Location Check: User IN RANGE. Garden visible.");
                        }
                    } else {
                         if (this.hasEnteredRange) { // Only trigger on first exit
                             this.hasEnteredRange = false;
                             this.gardenEntity.setAttribute('visible', false); // Visibility change triggers flower reset via listener
                             if(this.mainMessageDisplay) this.mainMessageDisplay.style.display = 'none';
                             if(this.dynamicResponseDisplay) this.dynamicResponseDisplay.style.display = 'none';
                             if(this.responseToggleBtn) this.responseToggleBtn.style.display = 'none';
                             if(this.resetBtn) this.resetBtn.style.display = 'none';
                             const responseForm = document.getElementById('response-form-container');
                             if(responseForm) responseForm.style.display = 'none';
                             if(this.responseToggleBtn) this.responseToggleBtn.textContent = '+';
                             if(this.instructionsDiv) this.instructionsDiv.style.display = 'block';
                             console.log("Location Check: User OUT OF RANGE. Garden hidden.");
                         }
                    }
                });
            }
        });

        // --- Global UI Event Listeners & Functions ---
        document.addEventListener('DOMContentLoaded', function() {
            // ... (Event listeners for buttons and form submission remain largely the same) ...
            const responseToggleBtn = document.getElementById('response-toggle');
            const responseFormContainer = document.getElementById('response-form-container');
            const gardenResponseForm = document.getElementById('garden-response-form-actual');
            const responseStatusDiv = document.getElementById('response-status');
            const resetBtn = document.getElementById('reset-btn');
            const gardenEntity = document.getElementById('gps-garden');
            const instructionsDiv = document.getElementById('instructions');
            const mainMessageDisplay = document.getElementById('main-message-display');
            const dynamicResponseTextDisplay = document.getElementById('dynamic-response-text-display');


            if (responseToggleBtn && responseFormContainer) {
                responseToggleBtn.addEventListener('click', function () {
                    const isFormVisible = responseFormContainer.style.display === 'block';
                    responseFormContainer.style.display = isFormVisible ? 'none' : 'block';
                    responseToggleBtn.textContent = isFormVisible ? '+' : '✕';
                });
            }

            if (resetBtn && gardenEntity) {
                resetBtn.addEventListener('click', function() {
                    // Reset button just explicitly hides things now, location check handles re-showing
                    gardenEntity.setAttribute('visible', false); // Hide the garden (triggers flower reset)                    
                    if(mainMessageDisplay) mainMessageDisplay.style.display = 'none';
                    if(dynamicResponseTextDisplay) dynamicResponseTextDisplay.style.display = 'none';
                    if(responseToggleBtn) responseToggleBtn.style.display = 'none';
                    if(responseFormContainer) responseFormContainer.style.display = 'none';
                    if(responseToggleBtn) responseToggleBtn.textContent = '+';
                    if(resetBtn) resetBtn.style.display = 'none'; 
                    if(instructionsDiv) instructionsDiv.style.display = 'block';
                    const locationCheck = document.querySelector('[location-check]').components['location-check'];
                    if(locationCheck) locationCheck.hasEnteredRange = false; // Allow re-entry detection
                    console.log("Reset Button: Garden hidden by user.");
                });
            }

            if (gardenResponseForm && responseStatusDiv) {
                gardenResponseForm.addEventListener('submit', function(e) {
                     e.preventDefault();
                    const name = gardenResponseForm.name.value;
                    const message = gardenResponseForm.message.value;
                    const timestamp = new Date().toLocaleString();

                    if (!name || !message) {
                        responseStatusDiv.textContent = 'Please fill out all fields.';
                        responseStatusDiv.style.color = '#ff6b6b';
                        return;
                    }
                    responseStatusDiv.textContent = 'Submitting...';
                    responseStatusDiv.style.color = 'white';

                    const scriptURL = 'YOUR_APPS_SCRIPT_ID_HERE'; // <<< REPLACE
                    const formData = new FormData();
                    formData.append('name', name);
                    formData.append('message', message);
                    formData.append('timestamp', timestamp);
                    formData.append('action', 'submitResponse'); 

                    fetch(scriptURL, { method: 'POST', body: formData, mode: 'no-cors' })
                        .then(() => {
                            responseStatusDiv.textContent = 'Thank you for sharing!';
                            responseStatusDiv.style.color = '#4CAF50';
                            gardenResponseForm.reset();
                            setTimeout(() => { 
                                if(responseFormContainer) responseFormContainer.style.display = 'none';
                                if(responseToggleBtn) responseToggleBtn.textContent = '+';
                             }, 2000);
                             loadAndCycleResponses(false); // Reload responses
                        })
                        .catch(error => {
                            console.error('Error submitting response:', error);
                            responseStatusDiv.textContent = 'Submission error. Please try again.';
                            responseStatusDiv.style.color = '#ff6b6b';
                        });
                });
            }
            
            // iOS Motion Sensor Permission Handling (remain the same)
             const permissionOverlay = document.getElementById('permission-overlay');
             const permissionBtn = document.getElementById('permission-btn');
             const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

             if (isIOS && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                 if(permissionOverlay) permissionOverlay.style.display = 'flex';
                 if(permissionBtn) permissionBtn.addEventListener('click', function() {
                     DeviceMotionEvent.requestPermission().then(response => {
                         if (response === 'granted') {
                             if(typeof DeviceOrientationEvent.requestPermission === 'function') {
                                 DeviceOrientationEvent.requestPermission().then(orientationResponse => {
                                     if (orientationResponse === 'granted') {
                                         if(permissionOverlay) permissionOverlay.style.display = 'none';
                                     } else { alert('Device orientation permission denied.'); }
                                 });
                             } else {
                                 if(permissionOverlay) permissionOverlay.style.display = 'none';
                             }
                         } else { alert('Device motion permission denied.'); }
                     }).catch(console.error);
                 }, { once: true });
             } else {
                  if(permissionOverlay) permissionOverlay.style.display = 'none'; 
             }
        });
        
        // Dynamic Server Responses Logic (remains the same)
        let serverResponses = [];
        let currentResponseIndex = -1;
        let responseIntervalId = null;
        const dynamicResponseTextDisplay = document.getElementById('dynamic-response-text-display');

        function loadAndCycleResponses(isInitialCall = false) {
            const fetchScriptURL = 'YOUR_APPS_SCRIPT_ID_HERE'; // <<< REPLACE 
            const defaultResponses = [
                { name: "Gardener", message: "Seeds of hope grow here." }, 
                { name: "Neighbor", message: "What a beautiful idea!" },
                { name: "Visitor", message: "This space has potential." }
            ];

            fetch(fetchScriptURL)
                // ... fetch logic remains the same ...
                 .then(response => {
                    if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                    return response.json();
                })
                .then(data => {
                    if (data.result === 'success' && data.responses && data.responses.length > 0) {
                        serverResponses = data.responses.map(r => ({ name: r.name || "Anonymous", message: r.message || ""}));
                        console.log(`Loaded ${serverResponses.length} responses from server.`);
                    } else {
                        serverResponses = defaultResponses;
                        console.log("No valid responses from server or error, using defaults.");
                    }
                })
                .catch(error => {
                    console.error('Error loading responses:', error);
                    serverResponses = defaultResponses; // Fallback to defaults on error
                })
                .finally(() => {
                    if (serverResponses.length > 0) {
                        if (responseIntervalId) clearInterval(responseIntervalId); 
                        if(isInitialCall) showNextResponse(); 
                        responseIntervalId = setInterval(showNextResponse, 10000);
                        if(dynamicResponseTextDisplay) dynamicResponseTextDisplay.style.display = 'block';
                    } else {
                        if(dynamicResponseTextDisplay) dynamicResponseTextDisplay.style.display = 'none';
                    }
                });
        }

        function showNextResponse() {
             // ... showNextResponse logic remains the same ...
             if (!serverResponses || serverResponses.length === 0 || !dynamicResponseTextDisplay) return;
            
            currentResponseIndex = (currentResponseIndex + 1) % serverResponses.length;
            const response = serverResponses[currentResponseIndex];
            
            dynamicResponseTextDisplay.textContent = `"${response.message}" - ${response.name}`;
            dynamicResponseTextDisplay.style.opacity = 0;
            setTimeout(() => { dynamicResponseTextDisplay.style.opacity = 1; }, 100);
        }

    </script>
</body>
</html>